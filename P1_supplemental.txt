Encho Genchev
Fabian Ochoa

Answer questions marked as "QS"

QS1.1:
DFS uses a stack. DFS goes as deep as possible into the maze before backtracking to the most recent unexplored path.
A Stack is the optimal data structure for this because it can quickly push values to go deep into the maze and then quickly 
pop values until the most recent unexplored path is found. 

QS1.2:
Yes, the exploration order is what was expected. Pacman does NOT go to all the explored states since DFS had to backtrack a few times.

QS2.1:
BFS uses a queue because it needs to search the nodes closest to the start first before moving on. The FIFO behavior of a queue simplifies this
since the nodes placed first in the queue will be the layer closest to the start and the nodes later in the queue will be their successors.
This ensures BFS works properly and expands evenly in all directions.

QS3.1:
For the "StayEastSearchAgent" we used the cost function costFn = lambda pos: .5 ** pos[0]. This function penalizes positions further 
west (smaller x) and strongly rewards positions further east (larger x). Because the cost decreases exponentially as x increases, UCS prefers 
paths that stay as far east as possible, even if the path is longer in terms of steps. The exponential weighting causes the total path cost to be very small.
For the "StaryWestSearchAgent" we used the cost function costFn = lambda pos: 2 ** pos[0]. This function penalizes positions further east (larger x)
with exponentially increasing cost. As a result, UCS strongly favors paths that stay on the west side of the board. Even a small movement east significantly
increases the total cost, which leads to very large path costs overall.

QS4.1:
The nullHeuristic simply returns 0 making it equivilant to the UCS algorithm. The manhattanHeuristic calulates the function 
abs(xy1[0] - xy2[0]) + abs(xy1[1] - xy2[1]) giving the distance from the node to the goal. The manhattanHeuristic is better because it gives the 
algorithm more information about the states distance from the goal which is used to expand on better nodes quicker.

QS5.1:
The state representation for this problem consists of the current position of pacman (x, y) and a tuple containing boolean values for each corner,
the value being true if the corner has been visited and false if not. This tracks where pacman is and what corners still need to be visited.
This also keeps the state space minimal since we only care about pacman getting to all four corners, not necessarily all the combinations of paths
to get there.

QS5.2:
The corners problem gets the start state and checks if pacman starts in a corner, changing the boolean value of that corner accordingly. A search algorithm
can then use the getSuccessors to test every direction that pacman can move to find the four corners. GetSuccessors checks all 4 directions, makes sure that
pacman does not hit a wall, and updates the corner values if pacman ends up in a corner. When the goal state is found and all boolean values of visited_corners
are true, that means pacman can take the path found by the search algorithm to each corner.

QS6.1:


QS7.1:
We used a heuristic that returns the maximum maze distance from the current position to any remaining food dot. This heuristic is admissible because any 
solution must at least reach the farthest food, and it is more informative than Manhattan distance since it accounts for walls. Its main weakness is that 
it ignores the cost of visiting multiple food dots. The heuristic value can change by at most the cost of a single move.


QS8.1:
The solution works by first getting a list of all the food in the problem. Then we iterate through the food calculating the distance for each 
using mazeDistance(). Once the closest is found we create a problem in which the start state remains the same however we set the goal state to the food that
we determined has the shortest distance. Finally we use search.ucs() to get the shortest path from the start state to the closest food.  