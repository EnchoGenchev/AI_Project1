Encho Genchev
Fabian Ochoa

Answer questions marked as "QS"

QS1.1:
DFS uses a stack. DFS goes as deep as possible into the maze before backtracking to the most recent unexplored path.
A Stack is the optimal data structure for this because it can quickly push values to go deep into the maze and then quickly 
pop values until the most recent unexplored path is found. 

QS1.2:
Yes, the exploration order is what was expected. Pacman does NOT go to all the explored states since DFS had to backtrack a few times.

QS2.1:
BFS uses a queue because it needs to search the nodes closest to the start first before moving on. The FIFO behavior of a queue simplifies this
since the nodes placed first in the queue will be the layer closest to the start and the nodes later in the queue will be their successors.
This ensures BFS works properly and expands evenly in all directions.

QS3.1:
For the "StayEastSearchAgent" we used the cost function costFn = lambda pos: .5 ** pos[0]. This function penalizes positions further 
west (smaller x) and strongly rewards positions further east (larger x). Because the cost decreases exponentially as x increases, UCS prefers 
paths that stay as far east as possible, even if the path is longer in terms of steps. The exponential weighting causes the total path cost to be very small.
For the "StaryWestSearchAgent" we used the cost function costFn = lambda pos: 2 ** pos[0]. This function penalizes positions further east (larger x)
with exponentially increasing cost. As a result, UCS strongly favors paths that stay on the west side of the board. Even a small movement east significantly
increases the total cost, which leads to very large path costs overall.

QS4.1:


QS5.1:


QS5.2:


QS6.1:


QS7.1:
